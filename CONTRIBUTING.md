# ü§ù Contributing to ai.traiding

Vielen Dank f√ºr dein Interesse, zum ai.traiding Projekt beizutragen! Dieses Dokument beschreibt die Richtlinien und Best Practices f√ºr Beitr√§ge.

---

## üìã Inhaltsverzeichnis

- [Code of Conduct](#code-of-conduct)
- [Wie kann ich beitragen?](#wie-kann-ich-beitragen)
- [Development Setup](#development-setup)
- [Workflow & Branches](#workflow--branches)
- [Code Style & Standards](#code-style--standards)
- [Testing & QA](#testing--qa)
- [Pull Request Process](#pull-request-process)
- [Issue Guidelines](#issue-guidelines)
- [Dokumentation](#dokumentation)

---

## üìú Code of Conduct

Wir erwarten von allen Contributors:

- ‚úÖ Respektvoller und konstruktiver Umgang
- ‚úÖ Fokus auf technische Qualit√§t und L√∂sungen
- ‚úÖ Offenheit f√ºr Feedback und Code-Reviews
- ‚úÖ Keine pers√∂nlichen Angriffe oder unangemessene Kommentare

Bei Verst√∂√üen: Melde das Problem an die Maintainer √ºber GitHub Issues (privat).

---

## üéØ Wie kann ich beitragen?

### 1. üêõ Bug Reports

Gefunden einen Bug? Erstelle ein Issue mit:

- **Titel**: Kurze, pr√§gnante Beschreibung
- **Reproduktion**: Schritt-f√ºr-Schritt Anleitung
- **Expected vs. Actual**: Was sollte passieren? Was passiert tats√§chlich?
- **Environment**: OS, Python-Version, relevante Konfiguration
- **Logs**: Relevante Log-Ausgaben (ohne API-Keys!)

**Verwende das Issue Template**: `Bug Report` (falls vorhanden)

### 2. ‚ú® Feature Requests

Idee f√ºr ein neues Feature? √ñffne ein Issue mit:

- **Problem**: Welches Problem l√∂st das Feature?
- **L√∂sung**: Wie sollte die L√∂sung aussehen?
- **Alternativen**: Welche anderen Ans√§tze gibt es?
- **Use Case**: Wer profitiert davon? Warum ist es wichtig?

**Verwende das Issue Template**: `[Auto] Automation Task` oder `[Manual] Manual Task`

### 3. üîß Code Contributions

Bereit zu coden? Folge dem [Pull Request Process](#pull-request-process).

### 4. üìñ Dokumentation

Dokumentation verbessern ist immer willkommen:

- README.md Klarstellungen
- Code-Kommentare
- Guides und Tutorials
- API-Dokumentation

---

## üõ†Ô∏è Development Setup

### Windows (PowerShell) - Empfohlen ‚≠ê

**1. Repository klonen:**
```powershell
git clone https://github.com/CallMeMell/ai.traiding.git
cd ai.traiding
```

**2. Virtual Environment erstellen:**
```powershell
python -m venv venv
.\venv\Scripts\Activate.ps1
```

**3. Dependencies installieren:**
```powershell
# Production Dependencies
.\venv\Scripts\python.exe -m pip install -r requirements.txt

# Development Dependencies (optional)
.\venv\Scripts\python.exe -m pip install pytest pytest-cov black flake8
```

**4. .env Datei erstellen:**
```powershell
Copy-Item .env.example .env
# Bearbeite .env f√ºr deine lokale Konfiguration (DRY_RUN=true ist Standard)
```

**5. Tests ausf√ºhren:**
```powershell
.\venv\Scripts\python.exe -m pytest tests/ -v
```

### Linux / macOS

**1. Repository klonen:**
```bash
git clone https://github.com/CallMeMell/ai.traiding.git
cd ai.traiding
```

**2. Virtual Environment erstellen:**
```bash
python3 -m venv venv
source venv/bin/activate
```

**3. Dependencies installieren:**
```bash
pip install -r requirements.txt
pip install pytest pytest-cov black flake8  # Dev dependencies
```

**4. .env Datei erstellen:**
```bash
cp .env.example .env
# Edit .env f√ºr lokale Konfiguration
```

**5. Tests ausf√ºhren:**
```bash
python -m pytest tests/ -v
```

---

## üåø Workflow & Branches

### Branch-Strategie

- **`main`**: Produktions-Branch (stable)
- **`dev`**: Development-Branch (aktuelle Features)
- **`feature/*`**: Feature-Branches f√ºr neue Features
- **`fix/*`**: Bugfix-Branches
- **`docs/*`**: Dokumentations-Branches

### Development Workflow

**1. Branch erstellen:**
```powershell
# Windows PowerShell
git checkout dev
git pull origin dev
git checkout -b feature/mein-feature-name
```

**2. √Ñnderungen commiten:**
```powershell
git add .
git commit -m "feat: Add new feature XYZ

- Implemented feature XYZ
- Added tests for feature XYZ
- Updated documentation
"
```

**3. Push und PR erstellen:**
```powershell
git push origin feature/mein-feature-name
# Dann erstelle Pull Request auf GitHub
```

### Commit Message Konventionen

Wir nutzen [Conventional Commits](https://www.conventionalcommits.org/):

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:**
- `feat`: Neues Feature
- `fix`: Bugfix
- `docs`: Dokumentation
- `style`: Code-Formatierung (keine Logik-√Ñnderungen)
- `refactor`: Code-Refactoring (keine Features/Fixes)
- `test`: Tests hinzuf√ºgen/√§ndern
- `chore`: Build, Dependencies, Tooling

**Beispiele:**
```
feat(binance): Add retry logic with exponential backoff
fix(runner): Handle NoneType in session_store.get_events()
docs(readme): Add ENV variable reference table
test(adapter): Add unit tests for BinanceAdapter
```

---

## üé® Code Style & Standards

### Python Code Style

Wir folgen **PEP 8** mit einigen Anpassungen:

- **Line Length**: Max 100 Zeichen (nicht 79)
- **Indentation**: 4 Spaces
- **Quotes**: Double quotes `"` bevorzugt
- **Imports**: Gruppiert (stdlib, third-party, local)

**Formatierung mit Black:**
```powershell
# Windows
.\venv\Scripts\python.exe -m black . --line-length 100

# Linux/macOS
python -m black . --line-length 100
```

**Linting mit Flake8:**
```powershell
# Windows
.\venv\Scripts\python.exe -m flake8 . --max-line-length=100 --extend-ignore=E203,W503

# Linux/macOS
python -m flake8 . --max-line-length=100 --extend-ignore=E203,W503
```

### Code-Qualit√§t

**‚úÖ Best Practices:**
- **DRY** (Don't Repeat Yourself): Vermeide Code-Duplizierung
- **SOLID-Prinzipien**: Besonders Single Responsibility
- **Type Hints**: Nutze Type Hints f√ºr Funktionen/Methoden
- **Docstrings**: Dokumentiere √∂ffentliche Funktionen/Klassen
- **Error Handling**: Try-Except f√ºr kritische Bereiche
- **Logging**: Nutze das zentrale Logging-System

**‚ùå Vermeide:**
- Globale Variablen
- Magic Numbers (nutze Konstanten)
- Tief verschachtelte Logik (max 3-4 Ebenen)
- Hardcoded Paths (nutze `pathlib` oder relative Pfade)
- API-Keys oder Secrets im Code

### Beispiel: Guter Code

```python
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)

def calculate_moving_average(
    prices: List[float],
    window_size: int = 20
) -> Optional[float]:
    """
    Calculate moving average for given price list.
    
    Args:
        prices: List of price values
        window_size: Number of periods for MA calculation
        
    Returns:
        Moving average value or None if insufficient data
    """
    if len(prices) < window_size:
        logger.warning(f"Insufficient data for MA calculation: {len(prices)} < {window_size}")
        return None
    
    recent_prices = prices[-window_size:]
    moving_average = sum(recent_prices) / window_size
    
    logger.debug(f"MA({window_size}): {moving_average:.2f}")
    return moving_average
```

---

## üß™ Testing & QA

### Test-Strategie

Wir nutzen **pytest** f√ºr alle Tests:

- **Unit Tests**: Einzelne Funktionen/Klassen isoliert testen
- **Integration Tests**: Module zusammen testen
- **Smoke Tests**: Kritische Pfade durchlaufen (Runner, View)

### Tests ausf√ºhren

**Alle Tests:**
```powershell
# Windows
.\venv\Scripts\python.exe -m pytest tests/ -v

# Linux/macOS
python -m pytest tests/ -v
```

**Spezifische Test-Datei:**
```powershell
.\venv\Scripts\python.exe -m pytest tests/test_config.py -v
```

**Mit Coverage:**
```powershell
.\venv\Scripts\python.exe -m pytest tests/ --cov=. --cov-report=html
# √ñffne htmlcov/index.html im Browser
```

### Test-Anforderungen

**F√ºr neue Features:**
- ‚úÖ Mindestens 1 Unit Test pro neue Funktion
- ‚úÖ Edge Cases abdecken (None, leere Listen, etc.)
- ‚úÖ Happy Path + Error Path

**F√ºr Bugfixes:**
- ‚úÖ Test der den Bug reproduziert (sollte vor Fix fehlschlagen)
- ‚úÖ Test sollte nach Fix erfolgreich sein

**Test-Struktur:**
```python
import pytest
from mymodule import my_function

def test_my_function_success():
    """Test successful case."""
    result = my_function(valid_input)
    assert result == expected_output

def test_my_function_empty_input():
    """Test with empty input."""
    result = my_function([])
    assert result is None

def test_my_function_invalid_type():
    """Test with invalid type."""
    with pytest.raises(TypeError):
        my_function("invalid")
```

### QA Checklist vor PR

- [ ] **Alle Tests laufen durch**: `pytest tests/ -v`
- [ ] **Keine Linting-Fehler**: `flake8 .`
- [ ] **Code formatiert**: `black .`
- [ ] **Neue Tests hinzugef√ºgt** (falls Feature/Bugfix)
- [ ] **Dokumentation aktualisiert** (README, Docstrings)
- [ ] **Keine Secrets im Code** (API-Keys, Passw√∂rter)
- [ ] **.env nicht committet** (nur .env.example)
- [ ] **Manuelle Tests durchgef√ºhrt** (falls UI/CLI-√Ñnderungen)

---

## üîÑ Pull Request Process

### 1. PR erstellen

**Titel:** Verwende Conventional Commits Format
```
feat(binance): Add retry logic with exponential backoff
```

**Beschreibung:** Nutze das PR-Template
```markdown
## üéØ √Ñnderungen

- Implemented retry logic for Binance API calls
- Added exponential backoff (1s, 2s, 4s, 8s)
- Updated BinanceAdapter tests

## üß™ Tests

- [x] Unit tests added (`test_binance_retry.py`)
- [x] All existing tests pass
- [x] Manual testing completed

## üìã Checklist

- [x] Code follows project style guidelines
- [x] Tests added/updated
- [x] Documentation updated
- [x] No secrets or API keys in code
- [x] PR targets correct branch (`dev`)

## üì∏ Screenshots (falls UI-√Ñnderungen)

[Screenshot einf√ºgen]
```

### 2. PR Review

**Reviewer pr√ºfen:**
- ‚úÖ Code-Qualit√§t und Style
- ‚úÖ Tests vorhanden und sinnvoll
- ‚úÖ Keine Breaking Changes (au√üer dokumentiert)
- ‚úÖ Dokumentation aktualisiert
- ‚úÖ Keine Sicherheitsprobleme

**Contributor reagiert auf Feedback:**
- √Ñnderungen umsetzen
- Commits pushen (werden automatisch zum PR hinzugef√ºgt)
- Review erneut anfordern

### 3. Merge

Nach Approval:
- **Squash and Merge** bevorzugt (f√ºr saubere History)
- Commit-Message editieren (falls n√∂tig)
- PR wird in `dev` gemergt
- Branch l√∂schen nach Merge

---

## üìä Merge Policy f√ºr Feature-PRs (Nach Sprint 0)

**Status:** ‚úÖ Aktiv seit Sprint 0 (80%+ Coverage erreicht)  
**Gilt f√ºr:** Alle Feature-PRs nach Sprint 0 Completion

### üéØ √úbersicht

Nach erfolgreichem Abschluss von Sprint 0 (80%+ Test Coverage f√ºr kritische Module) gelten **versch√§rfte Qualit√§tsanforderungen** f√ºr neue Features, um die erreichte Code-Qualit√§t zu halten und nachhaltig weiterzuentwickeln.

### ‚úÖ Pflicht-Kriterien f√ºr Merge

Ein Feature-PR kann **nur gemergt werden**, wenn alle folgenden Kriterien erf√ºllt sind:

#### 0. PR Synchronisation (Critical!)

**Anforderung:**
- ‚úÖ **PR ist mit main synchronisiert**: Branch muss auf dem aktuellen Stand von `main` basieren
- ‚úÖ **CI/CD pr√ºft automatisch**: GitHub Actions Workflow blockiert Merge bei veralteten PRs
- ‚úÖ **Keine veralteten Branches**: Verhindert Merge-Konflikte und veraltete Tests

**Automatische Pr√ºfung:**
Der Workflow `.github/workflows/require-up-to-date-main.yml` pr√ºft automatisch bei jedem PR:
- Merge-Base wird mit aktuellem main-HEAD verglichen
- Bei Abweichung: PR wird blockiert mit Anleitung zur Synchronisation
- Bei Erfolg: Gr√ºnes H√§kchen, PR kann weiter gepr√ºft werden

**Synchronisation durchf√ºhren:**

Windows PowerShell:
```powershell
# Option 1: Rebase (empfohlen f√ºr saubere History)
git fetch origin main
git rebase origin/main
git push --force-with-lease

# Option 2: Merge (einfacher, aber zus√§tzlicher Merge-Commit)
git fetch origin main
git merge origin/main
git push
```

Linux/macOS:
```bash
# Option 1: Rebase (empfohlen)
git fetch origin main
git rebase origin/main
git push --force-with-lease

# Option 2: Merge
git fetch origin main
git merge origin/main
git push
```

**Warum ist das wichtig?**
- ‚úÖ Tests laufen gegen aktuelle main-Basis
- ‚úÖ Coverage-Checks reflektieren neuesten Stand
- ‚úÖ Keine Merge-Konflikte beim finalen Merge
- ‚úÖ Alle neuen Features/Fixes aus main sind integriert

#### 1. Test Coverage (Critical!)

#### 2. Test Coverage (Critical!)

**Minimum Coverage:**
- ‚úÖ **Neue Code-Files**: Mindestens **80% Coverage**
- ‚úÖ **Ge√§nderte Files**: Coverage darf nicht sinken
- ‚úÖ **Kritische Module** (utils.py, binance_integration.py, broker_api.py): Bleiben ‚â•80%
- ‚úÖ **Gesamt-Coverage**: Keine Regression (mind. aktuelles Level halten)

**Coverage-Nachweis:**
```markdown
## üìä Test Coverage Report

### Coverage Summary
| Module | Coverage | Target | Status |
|--------|----------|--------|--------|
| new_feature.py | 85% | 80%+ | ‚úÖ |
| utils.py | 82% | 80%+ | ‚úÖ |
| **Total** | **81%** | **80%+** | **‚úÖ** |

### Test Statistics
- **New Tests**: 15
- **Total Tests**: 190 (+15)
- **Coverage Report**: [HTML Artifact Link]
```

**Template:** Siehe `.github/COVERAGE_COMMENT_TEMPLATE.md`

#### 3. Test-Qualit√§t

**Anforderungen:**
- ‚úÖ **Unit Tests**: Isolierte Tests f√ºr neue Funktionen
- ‚úÖ **Edge Cases**: Grenzf√§lle getestet (None, leere Listen, Fehler)
- ‚úÖ **Happy Path + Error Path**: Positive und negative Szenarien
- ‚úÖ **Mocking**: Externe Dependencies gemockt (API-Calls, etc.)
- ‚úÖ **Test-Namen**: Beschreibend und selbsterkl√§rend
- ‚úÖ **Keine Flaky Tests**: Tests m√ºssen deterministisch sein

**Test-Struktur Beispiel:**
```python
def test_calculate_sharpe_ratio_positive_returns():
    """Test Sharpe ratio calculation with positive returns."""
    returns = [0.01, 0.02, -0.01, 0.03]
    sharpe = calculate_sharpe_ratio(returns)
    assert sharpe > 0
    assert isinstance(sharpe, float)

def test_calculate_sharpe_ratio_zero_volatility():
    """Test Sharpe ratio edge case: zero volatility."""
    returns = [0.01, 0.01, 0.01, 0.01]
    sharpe = calculate_sharpe_ratio(returns)
    assert sharpe == 0.0
```

#### 4. CI Pipeline

**Alle Checks m√ºssen gr√ºn sein:**
- ‚úÖ **PR Synchronization Check**: `require-up-to-date-main.yml` Workflow passing
- ‚úÖ **Feature PR Coverage Check**: `feature-pr-coverage.yml` Workflow passing
- ‚úÖ **Main CI**: `ci.yml` Workflow passing (alle Plattformen + Python-Versionen)
- ‚úÖ **Linting**: Flake8, Black, isort checks passing
- ‚úÖ **System Tests**: Integration Tests erfolgreich

**Matrix Testing:**
- Windows + Ubuntu
- Python 3.10, 3.11, 3.12
- 6 Kombinationen (2 OS √ó 3 Python)

#### 5. Code-Qualit√§t

**Standards:**
- ‚úÖ **PEP 8**: Code Style Guidelines
- ‚úÖ **Type Hints**: Funktionen haben Type Annotations
- ‚úÖ **Docstrings**: √ñffentliche API dokumentiert
- ‚úÖ **DRY-Prinzip**: Keine Code-Duplizierung
- ‚úÖ **Error Handling**: Try-Except f√ºr kritische Pfade

#### 6. Dokumentation

**Pflicht-Updates:**
- ‚úÖ **README.md**: Neue Features beschrieben (falls User-facing)
- ‚úÖ **CHANGELOG.md**: √Ñnderungen dokumentiert
- ‚úÖ **.env.example**: Neue ENV-Variablen hinzugef√ºgt
- ‚úÖ **Docstrings**: Code dokumentiert
- ‚úÖ **Guides**: Feature-spezifische Guides (bei Bedarf)

#### 7. Sicherheit

**Security Checks:**
- ‚úÖ **Keine Secrets**: API-Keys, Tokens, Passw√∂rter nicht im Code
- ‚úÖ **DRY_RUN Default**: Trading-Features defaulten zu `DRY_RUN=true`
- ‚úÖ **.env nicht committed**: Nur `.env.example` versioniert

#### 8. Review

**Mindestanforderungen:**
- ‚úÖ **1 Approval**: Von Maintainer oder Core Team Member
- ‚úÖ **Review-Checkliste**: Siehe `.github/REVIEW_CHECKLIST.md`
- ‚úÖ **Alle Kommentare resolved**: Keine offenen Review-Threads
- ‚úÖ **Keine "Changes Requested"**: Alle angefragten √Ñnderungen umgesetzt

### üö´ Automatic Rejection Criteria

Ein PR wird **sofort abgelehnt** bei:

- ‚ùå **PR nicht mit main synchronisiert**
- ‚ùå **Coverage < 80%** f√ºr neuen Code
- ‚ùå **Coverage-Regression** bei kritischen Modulen
- ‚ùå **CI Tests failing**
- ‚ùå **Secrets committed** (API-Keys, Tokens)
- ‚ùå **Keine Tests** f√ºr neues Feature
- ‚ùå **Real Trading ohne DRY_RUN Default**

### üìã Review-Checkliste

Vollst√§ndige Review-Checkliste: **`.github/REVIEW_CHECKLIST.md`**

**Quick Check (f√ºr Reviewer):**
```markdown
- [ ] PR mit main synchronisiert
- [ ] Coverage ‚â• 80% f√ºr neuen Code
- [ ] CI Pipeline gr√ºn (alle Plattformen)
- [ ] Tests hinzugef√ºgt (Unit + Edge Cases)
- [ ] Dokumentation aktualisiert
- [ ] Code-Style Guidelines eingehalten
- [ ] Keine Secrets committed
- [ ] DRY_RUN Default korrekt
- [ ] Windows-Kompatibilit√§t getestet
```

### üîÑ Merge-Prozess

#### Schritt 1: Automated Checks (Pre-Review)
Vor manueller Review m√ºssen automatisch laufen:
1. ‚úÖ **CI Pipeline**: Alle Tests passing
2. ‚úÖ **Coverage Check**: 80%+ erreicht
3. ‚úÖ **Linting**: Style checks passing
4. ‚úÖ **System Tests**: Integration funktioniert

**Dauer:** ~5-10 Minuten (automatisch via GitHub Actions)

#### Schritt 2: Manual Review
Maintainer/Core Team reviewen:
1. **Code-Qualit√§t**: Review-Checkliste durchgehen
2. **Architektur**: Passt ins Gesamtbild?
3. **Tests**: Sinnvoll und ausreichend?
4. **Dokumentation**: Klar und vollst√§ndig?
5. **Security**: Keine Sicherheitsl√ºcken?

**Dauer:** 1-3 Tage (je nach Komplexit√§t)

#### Schritt 3: Feedback & Iteration
Bei "Changes Requested":
1. **Feedback lesen**: Alle Kommentare durchgehen
2. **√Ñnderungen umsetzen**: Code anpassen
3. **Re-Test**: Lokal testen
4. **Push Updates**: Commits pushen (automatisch zu PR hinzugef√ºgt)
5. **Re-Request Review**: Review erneut anfordern

#### Schritt 4: Approval & Merge
Nach Approval und gr√ºnen Checks:
1. **Final Check**: Maintainer √ºberpr√ºft nochmals
2. **Squash and Merge**: Commits zu einem zusammenfassen
3. **Commit Message**: Conventional Commits Format
4. **Merge to Dev**: PR in `dev` Branch mergen
5. **Branch Cleanup**: Feature-Branch l√∂schen

### üìä Coverage-Integration in CI

**Workflow:** `.github/workflows/feature-pr-coverage.yml`

**Features:**
- ‚úÖ Automatische Coverage-Pr√ºfung bei jedem PR
- ‚úÖ Coverage-Threshold Check (80%+)
- ‚úÖ Kritische Module einzeln gepr√ºft
- ‚úÖ HTML Coverage Report als Artifact
- ‚úÖ Coverage Summary im PR (GitHub Step Summary)
- ‚úÖ Upload zu Codecov (optional)

**Beispiel CI-Output:**
```
üìä Coverage Summary
Total Coverage: 81% ‚úÖ

Critical Modules:
| Module | Coverage | Status |
|--------|----------|--------|
| utils.py | 82% | ‚úÖ |
| binance_integration.py | 78% | ‚úÖ |
| broker_api.py | 78% | ‚úÖ |
```

### üéì F√ºr Contributors

**Vor PR-Erstellung:**
1. ‚úÖ Tests lokal schreiben und ausf√ºhren
2. ‚úÖ Coverage lokal pr√ºfen (‚â•80%)
3. ‚úÖ Linting lokal durchf√ºhren
4. ‚úÖ Dokumentation aktualisieren
5. ‚úÖ Self-Review durchf√ºhren

**Coverage-Check lokal (Windows):**
```powershell
# Tests mit Coverage
.\venv\Scripts\python.exe -m pytest tests/ --cov=. --cov-report=term-missing --cov-report=html -v

# HTML Report √∂ffnen
Start-Process htmlcov\index.html
```

**Coverage-Check lokal (Linux/macOS):**
```bash
# Tests mit Coverage
python -m pytest tests/ --cov=. --cov-report=term-missing --cov-report=html -v

# HTML Report √∂ffnen
open htmlcov/index.html  # macOS
xdg-open htmlcov/index.html  # Linux
```

### üìö Weitere Ressourcen

**Policy-Dokumente:**
- **Review-Checkliste**: `.github/REVIEW_CHECKLIST.md`
- **Coverage-Template**: `.github/COVERAGE_COMMENT_TEMPLATE.md`
- **CI Workflow**: `.github/workflows/feature-pr-coverage.yml`

**Best Practices:**
- **Sprint 0 Validation**: `SPRINT_0_COVERAGE_VALIDATION.md`
- **CI Success Guide**: `CI_SUCCESS_AND_NEXT_STEPS.md`
- **Best Practices**: `BEST_PRACTICES_GUIDE.md`

### üéØ Ziel dieser Policy

Diese Policy sorgt f√ºr:
- ‚úÖ **Nachhaltige Code-Qualit√§t**
- ‚úÖ **Hohe Testabdeckung** (‚â•80%)
- ‚úÖ **Konsistente Standards**
- ‚úÖ **Vertrauensw√ºrdiger Code**
- ‚úÖ **Schnelle Iteration** (durch klare Kriterien)

**Nach Sprint 0 gilt:** Quality over Speed! üöÄ

---

## üìù Issue Guidelines

### Issue erstellen

Wir nutzen **GitHub Issue Forms** f√ºr standardisierte Issues:

**Verf√ºgbare Templates:**

1. **[Auto] Automation Task** - F√ºr automatisierte Aufgaben
   - Outcome-orientierter Titel
   - Messbare Acceptance Criteria
   - Klar definierter Scope

2. **[Manual] Manual Task** - F√ºr manuelle Schritte
   - Schritt-f√ºr-Schritt Checklist
   - Proof/Nachweis f√ºr Abschluss
   - Voraussetzungen dokumentiert

3. **[Epic] Epic Tracking** - F√ºr gr√∂√üere Initiativen
   - Milestones und Sub-Issues
   - Definition of Done (DoD)
   - Success Metrics

**Beispiel-Titel:**
- ‚úÖ `[Auto] Live-Observability mit strukturierten Events und Real-time Monitoring`
- ‚úÖ `[Manual] API Keys f√ºr Binance Testnet einrichten`
- ‚ùå `View Session verbessern` (zu vage)

### Issue Labels

**Standard Labels:**
- `automation` - Automatisierte Tasks
- `manual` - Manuelle Tasks
- `epic` - Gr√∂√üere Initiativen
- `bug` - Fehlerbehebung
- `enhancement` - Verbesserung
- `documentation` - Dokumentation
- `help wanted` - Community-Hilfe erw√ºnscht
- `good first issue` - Gut f√ºr Einsteiger

### Issue Best Practices

**‚úÖ Gute Issues:**
- Messbare Acceptance Criteria
- Klarer Scope und Non-Goals
- Referenzen zu verwandten Issues/PRs
- Konkrete Beispiele

**‚ùå Schlechte Issues:**
- Vage Beschreibungen ("Code funktioniert nicht")
- Fehlende Reproduktionsschritte
- Keine Acceptance Criteria
- Zu breiter Scope

---

## üìö Dokumentation

### Dokumentations-Standards

**README.md:**
- Quickstart-Anleitung
- Feature-√úbersicht
- ENV-Variablen-Referenz
- Windows-first Fokus

**Code-Dokumentation:**
- Docstrings f√ºr √∂ffentliche Funktionen/Klassen
- Inline-Kommentare f√ºr komplexe Logik
- Type Hints f√ºr bessere IDE-Unterst√ºtzung

**Guides:**
- Schritt-f√ºr-Schritt Anleitungen
- Screenshots/Diagramme (falls hilfreich)
- Windows + Linux/macOS Befehle

### Dokumentation aktualisieren

**Bei Code-√Ñnderungen:**
- [ ] README.md aktualisieren (falls User-facing)
- [ ] Docstrings anpassen
- [ ] CHANGELOG.md erg√§nzen (siehe [CHANGELOG.md](CHANGELOG.md))

**Bei neuen Features:**
- [ ] Feature in README.md beschreiben
- [ ] Beispiele hinzuf√ºgen
- [ ] Neuen Guide erstellen (falls n√∂tig)
- [ ] ENV-Variablen dokumentieren (falls hinzugef√ºgt)

---

## üöÄ Windows-First Development

Dieses Projekt priorisiert **Windows-Entwicklung** mit PowerShell:

### ‚úÖ Best Practices

**PowerShell-Scripts verwenden:**
```powershell
# Direct venv calls (Windows-first)
.\venv\Scripts\python.exe -m pytest tests/
.\venv\Scripts\python.exe -m black .

# Nicht: source venv/bin/activate (Linux-only)
```

**python-dotenv CLI nutzen:**
```powershell
# Load .env with override flag
.\venv\Scripts\python.exe -m dotenv -f .env --override run python main.py

# Nicht: Manual .env parsing in scripts
```

**Cross-Platform Support:**
- Prim√§r: Windows PowerShell
- Sekund√§r: Linux/macOS Bash (via `pathlib`, `os.path`)

### üì¶ Dependencies verwalten

**Packages installieren (Windows):**
```powershell
.\venv\Scripts\python.exe -m pip install <package>
.\venv\Scripts\python.exe -m pip freeze > requirements.txt
```

**Neue Dependencies:**
- [ ] Zu `requirements.txt` hinzuf√ºgen
- [ ] Begr√ºndung im PR angeben
- [ ] Lizenz pr√ºfen (MIT, Apache 2.0 bevorzugt)

---

## ‚ùì FAQ f√ºr Contributors

### "Wie finde ich ein gutes erstes Issue?"

Suche nach Label: `good first issue` oder `help wanted`

### "Darf ich mehrere Issues gleichzeitig bearbeiten?"

Ja, aber erstelle separate Branches und PRs f√ºr jedes Issue.

### "Mein PR wurde abgelehnt - was nun?"

- Lies das Feedback der Reviewer
- Frag nach, falls etwas unklar ist
- Implementiere die gew√ºnschten √Ñnderungen
- Pushe Updates (werden automatisch zum PR hinzugef√ºgt)

### "Wie teste ich Live-Trading Features?"

**Niemals mit echtem Geld testen!**
- Nutze `DRY_RUN=true` (Standard)
- Nutze Binance Testnet f√ºr Paper Trading
- Siehe [LIVE_TRADING_SETUP_GUIDE.md](LIVE_TRADING_SETUP_GUIDE.md)

### "Brauche ich API-Keys f√ºr Development?"

**Nein!** DRY_RUN-Modus funktioniert ohne API-Keys:
- Simulierte Daten werden generiert
- Events werden lokal gespeichert
- View Session funktioniert einwandfrei

---

## üìû Kontakt & Hilfe

**Fragen oder Probleme?**

- üí¨ **GitHub Discussions** - Community Q&A
- üêõ **GitHub Issues** - Bug Reports & Feature Requests
- üìñ **Dokumentation** - README.md, Guides, SECURITY.md

**Danke f√ºr deinen Beitrag! üôè**

---

**Made for Windows ‚≠ê | PowerShell-First | DRY_RUN Default**
